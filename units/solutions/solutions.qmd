---
title: "Solutions"
format:
  html:
    theme: cosmo
    css: ../assets/styles.css
    toc: true
    code-copy: true
    code-tools: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
execute:
  freeze: auto
---

```{r chunksetup, include=FALSE, cache=TRUE} 
# include any code here you don't want to show up in the document,
# e.g. package and dataset loading
if(Sys.getenv('USER') == 'paciorek') rm(list = ls())
library(gapminder)
```

# Unit 1: Data Structures and Manipulations


## Basics

1) Extract the 5th row from the gapminder dataset.

```{r}
#| eval: false
gapminder[5, ]
```

2) Extract the last row from the gapminder dataset. 

```{r}
#| eval: false
gapminder[ nrow(gapminder) , ]
```

3) Create a boolean (TRUE/FALSE) vector indicating whether total country GDP is greater than 1 trillion dollars. When entering 1 trillion, use R's scientific notation.

```{r}
#| eval: false
large <- gapminder$gdpPercap * gapminder$pop > 1e12
```

4) Count the number of gdpPercap values greater than 50000 in the gapminder dataset.

```{r}
#| eval: false
sum(gapminder$gdpPercap > 50000)
```

5) Set all of the gdpPercap values greater than 50000 to NA. You should probably first copy the `gapminder` object and work on the copy so that the dataset is unchanged, so that you preserve the original data to use later.

```{r}
#| eval: false
gapminder2 <- gapminder
gapminder2$gdpPercap[ gapminder2$gdpPercap > 50000 ] <- NA
```

6) Consider the first row of the gapminder dataset, which has Afghanistan for 1952. How do I create a string "Afghanistan-1952" using `gap$country[1]` and `gap$year[1]`?

```{r}
#| eval: false
paste(gapminder$country[1], gapminder$year[1], sep = "-")
```

## Using the ideas

7) Create a character string using `paste()` that tells the user how many rows there are in the data frame - do this programmatically such that it would work for any data frame regardless of how many rows it has. The result should look like this: "There are 1704 rows in the dataset"

```{r}
#| eval: false
paste("There are ", nrow(gapminder), " rows in the dataset.", sep = "")
```

8) If you didn't do it this way already in problem #2, extract the last row from the gapminder dataset without typing the number '1704'.

```{r}
#| eval: false
gapminder[ nrow(gapminder), ]
```

9) Create a boolean vector indicating if the life expectancy is greater than 75 and the gdpPercap is less than 10000 and calculate the proportion of all the records these represent.

```{r}
#| eval: false
economical <- gapminder$lifeExp > 75 & gapminder$gdpPercap < 10000
mean(economical)   # sum(economical) / length(economical)
```

10) Use that vector to create a new data frame that is a subset of the original data frame.

```{r}
#| eval: false
sub <- gapminder[ economical , ]
```

11) Consider the attributes of the gapminder dataset. What kind of R object is the set of attributes?

```{r}
#| eval: false
attributes(gapminder)
names(attributes(gapminder))
class(attributes(gapminder))
```

## Advanced

12) Consider the following regression model.  Figure out how to extract the $R^2$ and residual standard error and store in new R variables. 

```{r}
#| eval: false
mod <- lm(lifeExp ~ log(gdpPercap), data = gapminder)
summ <- summary(mod)
r2 <- summ$r.squared
sigError <- summ$sigma
```


13) Create row names for the data frame based on concatenating the Continent, Country, and Year fields.

```{r}
#| eval: false
head(gapminder)
nm <- paste(gapminder$continent, gapminder$country, gapminder$year, sep = "-")
attributes(gapminder)$row.names <- nm
head(gapminder)
```

# Unit 2: Calculations and Efficiency


## Basics

1) Create a vector of GDP per capita in units of Euros rather than dollars.

```{r}
#| eval: false
EurosPerDollar <- 1.1  
gdpPercap_euro <- gapminder$gdpPercap * EurosPerDollar
c(gdpPercap_euro[1], gapminder$gdpPercap[1])
```

2) Create a vector that concatenates the country and year to create a 'country-year' variable in a vectorized way using the string processing functions.

```{r}
#| eval: false
gapminder$country_year <- paste(gapminder$country, gapminder$year, sep = "-")
```

3) Use `table()` to figure out the number of countries available for each continent.

```{r}
#| eval: false
table(gapminder2007$continent)
```

## Using the ideas

4) Explain the steps of what this code is doing: `tmp <- gapminder[ , -which(names(gapminder) == "continent")]`.

```{r}
#| eval: false
tmp <- gapminder[ , -which(names(gapminder) == "continent")]

# column names
names(gapminder)
# logical indicating which = 'continent'
names(gapminder) == "continent"
# index of the continent column
which(names(gapminder) == "continent")
# exclude that column
gapminder[ , -which(names(gapminder) == "continent")] 
```

5) Compute the number of NAs in each column of the gapminder dataset using `sapply()` and making use of the `is.na()` function. It's possible to do this without writing a function.

```{r}
#| eval: false
sapply(gapminder, function(x) sum(is.na(x)))

## or without writing a function
colSums(sapply(gapminder, is.na))
```

6)  Suppose we have two categorical variables and we conduct a hypothesis test of independence. The chi-square statistic is: 

$$
\chi^2 = \sum_{i=1}^{n}\sum_{j=1}^{m} \frac{(y_{ij} - e_{ij})^2}{e_{ij}}, 
$$ 

where $e_{ij} = \frac{y_{i\cdot} y_{\cdot j}}{y_{\cdot \cdot}}$, with $y_{i\cdot}$ the sum of the values in the i'th row, $y_{\cdot j}$ the sum of values in the j'th column, and $y_{\cdot\cdot}$ the sum of all the values. Suppose I give you a matrix in R with the $y_{ij}$ values. 

You can generate a test matrix as: 
```{r, eval=FALSE}
y <- matrix(sample(1:10, 12, replace = TRUE), 
nrow = 3, ncol = 4)
```

Compute the statistic without *any* loops as follows:

  - First, assume you have the *e* matrix. How do you compute the statistic without loops as a function of `y` and `e`?
  - How can you construct the *e* matrix? Hint: the numerator of *e* is just an *outer product* for which the `outer()` function can be used.

```{r}
#| eval: false
y <- matrix(sample(1:10, 12, replace = TRUE), 
nrow = 3, ncol = 4)

yidot <- rowSums(y)
ydotj <- colSums(y)
e <- outer(yidot, ydotj) / sum(y)

chi2 <- sum( (y - e)^2 / e)
# chi2 <- sum(colSums( (y-e)^2 / e ))
```

## Advanced 

7) Here's a cool trick using `sapply` to pull off a particular element of a list of lists:

```{r}
params <- list(a = list(mn = 7, sd = 3), b = list(mn = 6,sd = 1), 
  c = list(mn = 2, sd = 1))
  
sapply(params, "[[", 1)
```

Explain what that does and why it works.

Hint:
```{r}
test <- list(5, 7, 3)
test[[2]]
# `[[`(test, 2)  # need it commented or R Markdown processing messes it up...

# `+`(3, 7)
```

```{r}
#| eval: false
params[[1]][[1]]  # Same as:  `[[`(params[[1]], 1)
params[[2]][[1]]  # Same as:  `[[`(params[[3]], 1)
params[[3]][[1]]  # Same as:  `[[`(params[[3]], 1)
# etc.