---
title: "Solutions"
format:
  html:
    theme: cosmo
    css: ../assets/styles.css
    toc: true
    code-copy: true
    code-tools: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
execute:
  freeze: auto
---

```{r chunksetup, include=FALSE, cache=TRUE} 
# include any code here you don't want to show up in the document,
# e.g. package and dataset loading
if(Sys.getenv('USER') == 'paciorek') rm(list = ls())
library(gapminder)
```

# Unit 1: Data Structures and Manipulations


## Basics

1) Extract the 5th row from the gapminder dataset.

```{r}
#| eval: false
gapminder[5, ]
```

2) Extract the last row from the gapminder dataset. 

```{r}
#| eval: false
gapminder[ nrow(gapminder) , ]
```

3) Create a boolean (TRUE/FALSE) vector indicating whether total country GDP is greater than 1 trillion dollars. When entering 1 trillion, use R's scientific notation.

```{r}
#| eval: false
large <- gapminder$gdpPercap * gapminder$pop > 1e12
```

4) Count the number of gdpPercap values greater than 50000 in the gapminder dataset.

```{r}
#| eval: false
sum(gapminder$gdpPercap > 50000)
```

5) Set all of the gdpPercap values greater than 50000 to NA. You should probably first copy the `gapminder` object and work on the copy so that the dataset is unchanged, so that you preserve the original data to use later.

```{r}
#| eval: false
gapminder2 <- gapminder
gapminder2$gdpPercap[ gapminder2$gdpPercap > 50000 ] <- NA
```

6) Consider the first row of the gapminder dataset, which has Afghanistan for 1952. How do I create a string "Afghanistan-1952" using `gap$country[1]` and `gap$year[1]`?

```{r}
#| eval: false
paste(gapminder$country[1], gapminder$year[1], sep = "-")
```

## Using the ideas

7) Create a character string using `paste()` that tells the user how many rows there are in the data frame - do this programmatically such that it would work for any data frame regardless of how many rows it has. The result should look like this: "There are 1704 rows in the dataset"

```{r}
#| eval: false
paste("There are ", nrow(gapminder), " rows in the dataset.", sep = "")
```

8) If you didn't do it this way already in problem #2, extract the last row from the gapminder dataset without typing the number '1704'.

```{r}
#| eval: false
gapminder[ nrow(gapminder), ]
```

9) Create a boolean vector indicating if the life expectancy is greater than 75 and the gdpPercap is less than 10000 and calculate the proportion of all the records these represent.

```{r}
#| eval: false
economical <- gapminder$lifeExp > 75 & gapminder$gdpPercap < 10000
mean(economical)   # sum(economical) / length(economical)
```

10) Use that vector to create a new data frame that is a subset of the original data frame.

```{r}
#| eval: false
sub <- gapminder[ economical , ]
```

11) Consider the attributes of the gapminder dataset. What kind of R object is the set of attributes?

```{r}
#| eval: false
attributes(gapminder)
names(attributes(gapminder))
class(attributes(gapminder))
```

## Advanced

12) Consider the following regression model.  Figure out how to extract the $R^2$ and residual standard error and store in new R variables. 

```{r}
#| eval: false
mod <- lm(lifeExp ~ log(gdpPercap), data = gapminder)
summ <- summary(mod)
r2 <- summ$r.squared
sigError <- summ$sigma
```


13) Create row names for the data frame based on concatenating the Continent, Country, and Year fields.

```{r}
#| eval: false
head(gapminder)
nm <- paste(gapminder$continent, gapminder$country, gapminder$year, sep = "-")
attributes(gapminder)$row.names <- nm
head(gapminder)
```

# Unit 2: Calculations and Efficiency


## Basics

1) Create a vector of GDP per capita in units of Euros rather than dollars.

```{r}
#| eval: false
EurosPerDollar <- 1.1  
gdpPercap_euro <- gapminder$gdpPercap * EurosPerDollar
c(gdpPercap_euro[1], gapminder$gdpPercap[1])
```

2) Create a vector that concatenates the country and year to create a 'country-year' variable in a vectorized way using the string processing functions.

```{r}
#| eval: false
gapminder$country_year <- paste(gapminder$country, gapminder$year, sep = "-")
```

3) Use `table()` to figure out the number of countries available for each continent.

```{r}
#| eval: false
table(gapminder2007$continent)
```

## Using the ideas

4) Explain the steps of what this code is doing: `tmp <- gapminder[ , -which(names(gapminder) == "continent")]`.

```{r}
#| eval: false
tmp <- gapminder[ , -which(names(gapminder) == "continent")]

# column names
names(gapminder)
# logical indicating which = 'continent'
names(gapminder) == "continent"
# index of the continent column
which(names(gapminder) == "continent")
# exclude that column
gapminder[ , -which(names(gapminder) == "continent")] 
```

5) Compute the number of NAs in each column of the gapminder dataset using `sapply()` and making use of the `is.na()` function. It's possible to do this without writing a function.

```{r}
#| eval: false
sapply(gapminder, function(x) sum(is.na(x)))

## or without writing a function
colSums(sapply(gapminder, is.na))
```

6) Suppose we have two categorical variables and we conduct a hypothesis test of independence. The chi-square statistic is: 

$$
\chi^2 = \sum_{i=1}^{n}\sum_{j=1}^{m} \frac{(y_{ij} - e_{ij})^2}{e_{ij}}, 
$$ 

where $e_{ij} = \frac{y_{i\cdot} y_{\cdot j}}{y_{\cdot \cdot}}$, with $y_{i\cdot}$ the sum of the values in the i'th row, $y_{\cdot j}$ the sum of values in the j'th column, and $y_{\cdot\cdot}$ the sum of all the values. Suppose I give you a matrix in R with the $y_{ij}$ values. 

You can generate a test matrix as: 
```{r, eval=FALSE}
y <- matrix(sample(1:10, 12, replace = TRUE), 
nrow = 3, ncol = 4)
```

Compute the statistic without *any* loops as follows:

  - First, assume you have the *e* matrix. How do you compute the statistic without loops as a function of `y` and `e`?
  - How can you construct the *e* matrix? Hint: the numerator of *e* is just an *outer product* for which the `outer()` function can be used.

```{r}
#| eval: false
y <- matrix(sample(1:10, 12, replace = TRUE), 
nrow = 3, ncol = 4)

yidot <- rowSums(y)
ydotj <- colSums(y)
e <- outer(yidot, ydotj) / sum(y)

chi2 <- sum( (y - e)^2 / e)
# chi2 <- sum(colSums( (y-e)^2 / e ))
```

## Advanced 

7) Here's a cool trick using `sapply` to pull off a particular element of a list of lists:

```{r}
params <- list(a = list(mn = 7, sd = 3), b = list(mn = 6,sd = 1), 
  c = list(mn = 2, sd = 1))
  
sapply(params, "[[", 1)
```

Explain what that does and why it works.

Hint:
```{r}
test <- list(5, 7, 3)
test[[2]]
# `[[`(test, 2)  # need it commented or R Markdown processing messes it up...

# `+`(3, 7)
```

```{r}
#| eval: false
params[[1]][[1]]  # Same as:  `[[`(params[[1]], 1)
params[[2]][[1]]  # Same as:  `[[`(params[[3]], 1)
params[[3]][[1]]  # Same as:  `[[`(params[[3]], 1)
# etc.

# Unit 3: Programming Concepts and Tools

## Basics

1) Write an R function that will take an input vector and set any negative
values in the vector to zero.

```{r}
#| eval: false
truncate <- function(x) {
   x[x < 0] <- 0
   return(x)
}
```  

## Using the ideas

2) Write an R function that will take an input vector and set any value below a
threshold to be the value of threshold. Optionally, the function should instead
set values above a threshold to the value of the threshold.

```{r}
#| eval: false
truncate <- function(x, thresh = 0, below = TRUE) {
   if(below) {
      x[x < thresh] <- thresh
   } else x[x > thresh] <- thresh
   return(x)
}
```  


3) Augment your function so that it checks that the input is a numeric vector
and return an error if not. (See the help information for `stop()` (or `stopifnot()`.)

```{r}
#| eval: false
truncate <- function(x, thresh = 0, below = TRUE) {
   if(!is.numeric(x)) 
      stop("`x` must be a numeric vector")
   if(below) {
      x[x < thresh] <- thresh
   } else x[x > thresh] <- thresh
   return(x)
}
```  


4) Figure out what `invisible()` does and why it is useful when writing
functions. Use `invisible()` in your function from just above.

```{r}
#| eval: false
truncate <- function(x, thresh = 0, below = TRUE) {
   if(!inherits(x, 'numeric'))
      stop("`x` must be a numeric vector")
   if(below) {
      x[x < thresh] <- thresh
   } else x[x > thresh] <- thresh
   invisible(x)
}

x <- rnorm(20)
truncate(x)   # No output!
```  


## Advanced

5) Explore scoping in the following code. Explain why the result is 11 and not 3. Note that `funGenerator()` returns a function as the return object,
consistent with the idea that functions are objects in R. This is an example of
what is called a *closure* in R. Basically, the function contains object(s)
enclosed with and accessible to the function.

   ```{r, closure-scoping}
   funGenerator <- function(x) {
     x <- 10
     g <- function(y) {
       return(x + y)
     }
     return(g)
   }

   x <- 2
   f <- funGenerator()
   f(1)

   # `f` is a copy of `g`, which was created in the scope of `funGenerator`, not in the global environment.
   ls(environment(f))
   environment(f)$x
   ```

# Unit 4: Data Wrangling

## `dplyr`

1) Use `dplyr` to create a data frame containing the median `lifeExp` for each continent

   ```{r}
   #| eval: false
   gapminder_median_lifeExp <- gapminder %>%
   group_by(continent) %>%
   summarize(med_lifeExp = median(lifeExp))
   ```

2) Use `dplyr` to add a column to the gapminder dataset that contains the total population of the continent of each observation in a given year. For example, if the first observation is Afghanistan in 1952, the new column would contain the population of Asia in 1952.

   ```{r}
   #| eval: false
   gapminder_pop_continent <- gapminder %>%
   group_by(continent, year) %>%
   mutate(continent_pop = sum(pop))
   ```

3) Use `dplyr` to add a column called `gdpPercap_diff` that contains the difference between the observation's `gdpPercap` and the mean `gdpPercap` of the continent in that year. Arrange the data frame by the column you just created, in descending order (so that the relatively richest country/years are listed first)

   ```{r}
   #| eval: false
   gapminder_rel_gdp <- gapminder %>%
   group_by(continent, year) %>%
   mutate(gdpPercap_diff = gdpPercap - mean(gdpPercap)) %>%
   arrange(desc(gdpPercap_diff))
   ```

## `tidyr`

4) Subset the results from question #3 to select only the `country`, `year`, and `gdpPercap_diff` columns. Use tidyr put it in wide format so that countries are rows and years are columns.

   Hint: you'll probably see a message about a missing grouping variable. If you don't want continent included, you can pass the output of problem 3 through `ungroup()` to get rid of the continent information.

   ```{r}
   #| eval: false
   ## First, redo question 3 code, without arranging by gdp,
   ## as that would mess up the order of the columns in the 'wide' result.
   gapminder_rel_gdp <- gapminder %>%
   group_by(continent, year) %>%
   mutate(gdpPercap_diff = gdpPercap - mean(gdpPercap))

   ## Now convert to wide format.
   gapminder_wider <- gapminder_rel_gdp %>% 
   select(country, year, gdpPercap_diff) %>%
   pivot_wider(names_from = year, values_from = gdpPercap_diff) 
   ```

## `data.table`

5) Compare timing of some operations on the airline dataset when using `dtplyr` with `lazy_air` versus directly applying dplyr syntax to the `air` data.table obect.

   No solution provided.